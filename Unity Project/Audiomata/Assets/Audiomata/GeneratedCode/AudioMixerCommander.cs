

namespace Audiomata.ComponentTrackers
{
    using Audiomata;
    //-------------------------------------------------------------------------------------------------------------------------------
    //					THIS CODE IS AUTOMATICALLY GENERATED, DO NOT MODIFY
    //-------------------------------------------------------------------------------------------------------------------------------
    using UnityEngine.Audio;
    using UnityEngine;
    // Auto generated props, can use reflections but don't because it is REALLY slow
    #region EnumeratedProps
    public enum AudioMixerMembers
    {
        updateMode
        ,outputAudioMixerGroup,
       // TransistionToSnapShots,
       // ClearFloat,
       // SetFloat

    }
    #endregion

    #region CommmandManager
    //Class to manage state of components
    public class AudioMixerCommander : IAudioCommandable
    {
        private LimitedStack<AudioCommand<AudioMixer>> audioCommands;

        //snapshot commands go on their own seperate stack because they have a lot of variables and do not work the same way as setting a value

        public AudioMixer Target { get; private set; }

        public AudioMixerCommander(AudioMixer target)
        {
            audioCommands = new LimitedStack<AudioCommand<AudioMixer>>();
            Target = target;
            
        }

        public AudioCommand<AudioMixer> CreateCommand(int enumeratedProp)
        {
            AudioCommand<AudioMixer> newCommand = CommandFactory(enumeratedProp);
            audioCommands.Push(newCommand);
            return newCommand;
        }

        public object DoCommand<T>(T value, int enumeratedProp)
        {
            AudioCommand<AudioMixer> newCommand = CommandFactory(enumeratedProp);
            newCommand.Do(value);
            audioCommands.Push(newCommand);
            return newCommand;
        }

        public object RegisterCommand(int enumeratedProp)
        {
            AudioCommand<AudioMixer> newCommand = CommandFactory(enumeratedProp);
            audioCommands.Push(newCommand);
            return newCommand;
        }

        public void UndoCommand(object cmd)
        {
            AudioCommand<AudioMixer> command = (AudioCommand<AudioMixer>)cmd;
            command.Undo();
            audioCommands.Remove(command);
        }


        public void UndoLast()
        {
            if (audioCommands.Count < 1)
            {
                return;
            }

            AudioCommand<AudioMixer> popped = audioCommands.Pop();
            popped.Undo();
        }

        public void UndoAll()
        {
            while (audioCommands.Count > 0)
            {
                AudioCommand<AudioMixer> popped = audioCommands.Pop();
                popped.Undo();
            }
        }

        public void ClearChangeHistory()
        {
            while (audioCommands.Count > 0)
            {
                AudioCommand<AudioMixer> popped = audioCommands.Pop();
            }
        }

        private AudioCommand<AudioMixer> CommandFactory(int enumeratedProp)
        {
            AudioMixerMembers commandPropTarget = (AudioMixerMembers)enumeratedProp;
            AudioCommand<AudioMixer> nextCommand;
            switch (commandPropTarget)
            {
                //case AudioMixerMembers.TransistionToSnapShots:
                    
                  //  return null;
                case AudioMixerMembers.outputAudioMixerGroup:
                    nextCommand = new AudioMixerCmdOutputAudioMixerGroup(Target);
                    return nextCommand;
                case AudioMixerMembers.updateMode:
                    nextCommand = new AudioMixerCmdUpdateMode(Target);
                    return nextCommand;
                default:
                    return null;
            }
        }
    }

    #endregion

    #region AutoGeneratedCommands
    public class AudioMixerCmdOutputAudioMixerGroup : AudioCommand<AudioMixer>, IAudioCommand<AudioMixerGroup>
    {

        public AudioMixerGroup InitialValue { get;  set; }
        public AudioMixerGroup FinalValue { get; set; }
        public CommandState CommandState { get; set; }


        public AudioMixerCmdOutputAudioMixerGroup(AudioMixer target)
        {
            Target = target;
        }

        public override void Do(object newValue)
        {
            InitialValue = Target.outputAudioMixerGroup;
            FinalValue = (AudioMixerGroup)newValue;
            Target.outputAudioMixerGroup = FinalValue;
        }

        public void Do(AudioMixerGroup newValue)
        {
            InitialValue = Target.outputAudioMixerGroup;
            FinalValue = newValue;
            Target.outputAudioMixerGroup = FinalValue;
        }

        public int TargetPropEnum()
        {
            return (int)AudioMixerMembers.outputAudioMixerGroup;
        }

        public override void Undo()
        {
            Target.outputAudioMixerGroup = InitialValue;
        }

    }

    public class AudioMixerCmdUpdateMode : AudioCommand<AudioMixer>, IAudioCommand<AudioMixerUpdateMode>
    {

        public AudioMixerUpdateMode InitialValue { get; set; }
        public AudioMixerUpdateMode FinalValue { get; set; }
        public CommandState CommandState { get; set; }


        public AudioMixerCmdUpdateMode(AudioMixer target)
        {
            Target = target;
        }

        public override void Do(object newValue)
        {
            InitialValue = Target.updateMode;
            FinalValue = (AudioMixerUpdateMode)newValue;
            Target.updateMode = FinalValue;
        }

        public void Do(AudioMixerUpdateMode newValue)
        {
            InitialValue = Target.updateMode;
            FinalValue = newValue;
            Target.updateMode = FinalValue;
        }

        public int TargetPropEnum()
        {
            return (int)AudioMixerMembers.updateMode;
        }

        public override void Undo()
        {
            Target.updateMode = InitialValue;
        }

    }

   
     /*
    public class AudioMixerCmdTransistionToSnapshots : AudioCommand<AudioMixer>, IAudioCommand<AudioMixerSnapshot[]>
    {
        public AudioMixerSnapshot[] InitialValue { get; private set; }

        public AudioMixerSnapshot[] FinalValue {get; private set;}

        //for now these values will remain public as cmd patter assumed one param
        public float[] Weights { get; set; }
        public float  TransistionTime { get; set; }

        public CommandState CommandState { get; set; }

        public override void Do(object newValue)
        {
            AudioMixerSnapshot[] value = (AudioMixerSnapshot[])newValue;

            Target.TransitionToSnapshots(value, Weights, TransistionTime); 
        }

        public void Do(AudioMixerSnapshot[] newValue)
        {
            Target.TransitionToSnapshots(newValue, Weights, TransistionTime);
            
        }

        public int TargetPropEnum()
        {
            return (int)AudioMixerMembers.TransistionToSnapShots;
        }

        public override void Undo()
        {
            throw new System.NotImplementedException("Snapshots cannot be undone, unity seals mixer groups pretty tight! I advise you take a snapshot of the original state and apply and unapply them independently, don't worry though this will come to me in a dream as well");
        }
    }
    */
  

    #endregion
}


