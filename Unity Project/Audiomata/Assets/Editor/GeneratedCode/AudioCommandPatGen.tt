<#@ template language="C#" #>
<#@ import namespace="Audiomata.ComponentMapping" #>
<#@ import namespace="UnityEngine.Audio" #>
<#@ import namespace="UnityEngine" #>
<#@ import namespace = "Audiomata"#>

<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Reflection"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>

namespace Audiomata.ComponentTrackers
{
//-------------------------------------------------------------------------------------------------------------------------------
//					THIS CODE IS AUTOMATICALLY GENERATED, DO NOT MODIFY
//-------------------------------------------------------------------------------------------------------------------------------
<#
 string typeName = TargetClass.propType.Name;
 string outClassName = typeName+"Commander";
 string enumName = typeName+"Members";
 #>
using UnityEngine;
using UnityEngine.Audio;
using System.Collections.Generic;
using Audiomata;

 // Auto generated props, can use reflections but don't because it is REALLY slow
#region EnumeratedProps
 public enum <#=enumName#>
 {
	<# if(TargetClass.publicProps.Length>0){#>
          <#=TargetClass.publicProps[TargetClass.publicProps.Length-1].Name#>
<#
        for (int j = 0; j<TargetClass.publicProps.Length-1;j++){
		#>
		<#=","+TargetClass.publicProps[j].Name#>
	<#}#>	
	<#}#>
 }
#endregion

#region CommmandManager
 //Class to manage state of components
 public class <#=outClassName #> :IAudioCommandable
 {
	private LimitedStack<AudioCommand<<#=typeName#>> > audioCommands;
    public <#=typeName#> Target{get;private set;}

    public <#=outClassName#>()
    {
        audioCommands = new LimitedStack<AudioCommand<<#=typeName#>> >();
    }

    public object DoCommand<T>(T value, int enumeratedProp)
    {
        AudioCommand<<#=typeName#>> newCommand = CommandFactory(enumeratedProp);
        newCommand.Do(value);
        audioCommands.Push(newCommand);
        return newCommand;
    }
    
    public object RegisterCommand(int enumeratedProp)
    {
        AudioCommand<<#=typeName#>> newCommand = CommandFactory(enumeratedProp);
        audioCommands.Push(newCommand);
        return newCommand;
    }

    public void UndoCommand(object cmd)
    {
        AudioCommand<<#=typeName#>> command = (AudioCommand<<#=typeName#>>) cmd;
        command.Undo();
        audioCommands.Remove(command);
    }


    public void UndoLast()
    {
        if (audioCommands.Count<1)
        {
            return;
        }
        
        AudioCommand<<#=typeName#>> popped = audioCommands.Pop();
        popped.Undo();
    }

    public void UndoAll()
    {
        while (audioCommands.Count>0)
        {
            AudioCommand<<#=typeName#>> popped = audioCommands.Pop();
            popped.Undo();
        }
    }

    public void ClearChangeHistory()
    {
        while (audioCommands.Count>0)
        {
            AudioCommand<<#=typeName#>> popped = audioCommands.Pop();
        }
    }

    private AudioCommand<<#=typeName#>>CommandFactory(int enumeratedProp)
    {
        <#=enumName#> commandPropTarget = ( <#=enumName#> ) enumeratedProp;
            AudioCommand<<#=typeName#>> nextCommand;
        switch(commandPropTarget){
        <# 
    for (int i =0; i<TargetClass.publicProps.Length; i++){
        PropertyInfo nextProp = TargetClass.publicProps[i];
        string nextPropName= nextProp.Name;
        string nexCommandName= GetCommandName(nextPropName);
            #>
            case <#=enumName#>.<#=nextPropName#>:
                nextCommand = new <#=nexCommandName#>(Target);
            return nextCommand;
   <#}
#>        default:
            return null; 
      }
    }
 }

#endregion

#region AutoGeneratedCommands
	<#for (int j = 0; j<TargetClass.publicProps.Length;j++){
	PropertyInfo nextProp = TargetClass.publicProps[j];
	string nextType;
        string nextPropName= nextProp.Name;
        bool shouldStep= false;
    
        switch(nextProp.PropertyType.Name)
        {
            case "Single":
                nextType = "float";
                shouldStep = true;
                break;
            case "Boolean":
                nextType = "bool";
                break;
            case "String":
                nextType = "string";
                break;
            case "Int32":
                nextType = "int";
                shouldStep = true;
                break;
            case "UInt32":
                nextType = "uint";
                shouldStep = true;
                break;
            case "Byte":
                nextType = "byte";
                break;
            case "SByte":
                nextType = "sbyte";
                break;
            case "Int16":
                nextType = "short";
                shouldStep = true;
                break;
            case "Int64":
                nextType = "long";
                shouldStep = true;
                break;
            case "UInt64":
                nextType = "ulong";
                shouldStep = true;
                break;
            case "IntPtr":
                case "UIntPtr":
                continue;
            case "Char":
                nextType = "char";
                break;
            default:
                nextType = nextProp.PropertyType.Name;
                break;
        }
	
        string nextPropClassName = GetCommandName(nextProp.Name);
	#>
	public class <#=nextPropClassName#> : AudioCommand< <#=typeName#> >,IAudioCommand< <#=nextType#> >
{

	public <#=nextType#> InitialValue { get; private set; }
	public <#=nextType#> FinalValue { get; private set; }
	public CommandState CommandState {get;set;}
    

	public <#=nextPropClassName#>(<#=typeName#> target){
		Target = target;
	}

	public override void Do(object newValue){
		InitialValue = Target.<#=nextPropName#>;
		FinalValue = (<#=nextType#>) newValue;
		Target.<#=nextPropName#> = FinalValue;
	}

	public void Do(<#=nextType#> newValue){
		InitialValue = Target.<#=nextPropName#>;
		FinalValue = newValue;
		Target.<#=nextPropName#> = FinalValue;
	}

	public int TargetPropEnum()
	{
		return (int)<#=enumName#>.<#=nextPropName#>;
	}

	public override void Undo(){
	Target.<#=nextPropName#> = InitialValue;
	}
    <# if (shouldStep){#>

    public override void Step(float t){
            float diff = FinalValue - InitialValue;
        <# if (nextType == "float"){#>
            Target.<#=nextPropName#> = InitialValue+(t*diff);
    <#} else{#>
            Target.<#=nextPropName#> =InitialValue+(<#=nextType#>)(t*diff);  
    <#}#>
     }
 <# }#>

}
   
	<#}//end Command creation for #>
#endregion
}


<#+    public string GetCommandName(string propName){
        char[] capsTmpArr= propName.ToCharArray();
        capsTmpArr[0] = char.ToUpper(capsTmpArr[0]);
        return  TargetClass.propType.Name+"Cmd"+(new string(capsTmpArr));
} #>
<#+ public AudioClassData TargetClass {get;set;} #>
<#+ public string FileName {get{ return TargetClass.propType.Name+"Commander.cs";}} #>